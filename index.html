<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>실시간 메뉴 집계</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-slate-50 text-slate-900 min-h-screen">
  <div class="max-w-6xl mx-auto p-4 md:p-8 space-y-4">
    <header class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
      <div>
        <h1 class="text-xl md:text-2xl font-bold">실시간 메뉴 집계</h1>
        <p class="text-sm text-slate-600">
          PC/모바일에서 동시에 입력하면 즉시 동기화됩니다.
          <span id="sessionLabel" class="font-medium"></span>
        </p>
      </div>

      <div class="flex gap-2 items-center">
        <button id="resetBtn" class="px-3 py-2 rounded-lg bg-rose-600 text-white hover:bg-rose-700">
          전체 초기화(새 세션)
        </button>
      </div>
    </header>

    <!-- 입력 영역 -->
    <section class="bg-white rounded-2xl shadow-sm border p-4">
      <div class="grid grid-cols-1 md:grid-cols-12 gap-3 items-end">
        <div class="md:col-span-4">
          <label class="block text-sm font-medium mb-1">이름</label>
          <input id="nameInput" class="w-full px-3 py-2 rounded-lg border" placeholder="예: 강대희" />
        </div>

        <div class="md:col-span-5">
          <label class="block text-sm font-medium mb-1">메뉴</label>
          <input id="menuInput" class="w-full px-3 py-2 rounded-lg border" placeholder="예: 불고기 / 비빔밥 / 돈까스" />
          <p class="text-xs text-slate-500 mt-1">팁: 메뉴 표기는 동일하게(띄어쓰기/철자) 입력하면 집계가 더 정확해요.</p>
        </div>

        <div class="md:col-span-3 flex gap-2">
          <button id="addBtn" class="flex-1 px-3 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700">
            입력
          </button>
          <button id="quickClearBtn" class="px-3 py-2 rounded-lg border hover:bg-slate-50">
            비우기
          </button>
        </div>
      </div>

      <p id="status" class="text-sm text-slate-600 mt-3"></p>
    </section>

    <main class="grid grid-cols-1 lg:grid-cols-12 gap-4">
      <!-- 입력 리스트 -->
      <section class="bg-white rounded-2xl shadow-sm border overflow-hidden lg:col-span-7">
        <div class="p-4 border-b flex items-center justify-between">
          <h2 class="font-bold">입력 명단</h2>
          <span id="pendingCount" class="text-sm text-slate-600"></span>
        </div>

        <div class="max-h-[65vh] overflow-auto">
          <table class="w-full text-sm">
            <thead class="sticky top-0 bg-slate-100">
              <tr>
                <th class="text-left p-2 w-16">순번</th>
                <th class="text-left p-2 w-36">이름</th>
                <th class="text-left p-2">메뉴</th>
                <th class="text-left p-2 w-28">완료</th>
              </tr>
            </thead>
            <tbody id="pendingTbody"></tbody>
          </table>
        </div>
      </section>

      <!-- 메뉴 집계 -->
      <section class="bg-white rounded-2xl shadow-sm border overflow-hidden lg:col-span-5">
        <div class="p-4 border-b flex items-center justify-between">
          <h2 class="font-bold">메뉴별 집계</h2>
          <span id="menuTotal" class="text-sm text-slate-600"></span>
        </div>

        <div class="max-h-[65vh] overflow-auto">
          <table class="w-full text-sm">
            <thead class="sticky top-0 bg-slate-100">
              <tr>
                <th class="text-left p-2 w-28">수량</th>
                <th class="text-left p-2 w-40">메뉴</th>
                <th class="text-left p-2">이름</th>
              </tr>
            </thead>
            <tbody id="menuTbody"></tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <script type="module">
    // ===== Firebase SDK (모듈) =====
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, serverTimestamp,
      collection, addDoc, onSnapshot, query, orderBy, updateDoc
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyC55dwMjZ97RguQU4h7Ku8Tpjh_X7be6yM",
  authDomain: "food-fire-b6db8.firebaseapp.com",
  projectId: "food-fire-b6db8",
  storageBucket: "food-fire-b6db8.firebasestorage.app",
  messagingSenderId: "824034193268",
  appId: "1:824034193268:web:46016cdfbcd74402b24621"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ===== UI =====
    const $ = (id) => document.getElementById(id);
    const statusEl = $("status");
    const sessionLabelEl = $("sessionLabel");

    const pendingTbody = $("pendingTbody");
    const pendingCountEl = $("pendingCount");

    const menuTbody = $("menuTbody");
    const menuTotalEl = $("menuTotal");

    function setStatus(msg) { statusEl.textContent = msg || ""; }

    function safeText(s) {
      return (s ?? "").toString().replace(/[<>&"]/g, (c) => ({
        "<":"&lt;", ">":"&gt;", "&":"&amp;", '"':"&quot;"
      }[c]));
    }

    // 메뉴 입력 통일(앞뒤 공백 제거 + 연속 공백 1칸)
    function normalizeMenu(menu) {
      return String(menu ?? "")
        .trim()
        .replace(/\s+/g, " ");
    }

    function normalizeName(name) {
      return String(name ?? "").trim();
    }

    // ===== 데이터 구조 =====
    // app/state : { currentSessionId, updatedAt }
    // sessions/{sessionId} : { createdAt }
    // sessions/{sessionId}/entries/{entryId} : { name, menu, called, createdAt, calledAt }

    const stateRef = doc(db, "app", "state");
    let currentSessionId = null;
    let unsubscribeEntries = null;

    // 중복 체크용 캐시
    let cachedEntries = [];

    async function ensureState() {
      const snap = await getDoc(stateRef);
      if (!snap.exists() || !snap.data()?.currentSessionId) {
        const newId = crypto.randomUUID();
        await setDoc(doc(db, "sessions", newId), { createdAt: serverTimestamp() });
        await setDoc(stateRef, { currentSessionId: newId, updatedAt: serverTimestamp() });
      }
    }

    function computeMenuStats(entries) {
      // 메뉴별: count(인원수), names(Set)
      const map = new Map();

      for (const e of entries) {
        // 완료/미완료 상관 없이 집계하려면 그대로 두고,
        // "대기만 집계" 하고 싶으면 if (e.called) continue; 를 넣으면 됨.
        const menu = normalizeMenu(e.menu);
        const name = normalizeName(e.name);
        if (!menu || !name) continue;

        if (!map.has(menu)) map.set(menu, { menu, count: 0, names: new Set() });
        const obj = map.get(menu);
        obj.count += 1;
        obj.names.add(name);
      }

      // 수량 desc → 메뉴명 asc
      return Array.from(map.values())
        .sort((a, b) => (b.count - a.count) || a.menu.localeCompare(b.menu, "ko"));
    }

    function render(entries) {
      // 입력 순서 유지
      const list = entries.slice().sort((a, b) => {
        // createdAt이 서버타임이라 초기에 null일 수 있어 fallback
        const ta = a.createdAt?.seconds ?? 0;
        const tb = b.createdAt?.seconds ?? 0;
        if (ta !== tb) return ta - tb;
        return (a._idx ?? 0) - (b._idx ?? 0);
      });

      // 입력 리스트(대기/완료 스타일만 다르게)
      pendingTbody.innerHTML = list.map((e, idx) => `
        <tr class="border-b last:border-b-0 ${e.called ? "opacity-70" : ""}">
          <td class="p-2 text-slate-500">${idx + 1}</td>
          <td class="p-2 font-medium ${e.called ? "line-through" : ""}">${safeText(e.name)}</td>
          <td class="p-2 ${e.called ? "line-through" : ""}">${safeText(e.menu)}</td>
          <td class="p-2">
            ${e.called
              ? `<button data-id="${e.id}" class="undoBtn px-2 py-1 rounded-md border hover:bg-slate-50">취소</button>`
              : `<button data-id="${e.id}" class="doneBtn px-2 py-1 rounded-md bg-emerald-600 text-white hover:bg-emerald-700">완료</button>`
            }
          </td>
        </tr>
      `).join("");

      pendingCountEl.textContent = `총 ${list.length}건`;

      // 메뉴 집계
      const stats = computeMenuStats(entries);
      const totalCount = stats.reduce((sum, x) => sum + x.count, 0);
      menuTotalEl.textContent = `총 ${totalCount}건 · 메뉴 ${stats.length}종`;

      menuTbody.innerHTML = stats.map(s => {
        const names = Array.from(s.names).sort((a, b) => a.localeCompare(b, "ko"));
        return `
          <tr class="border-b last:border-b-0 align-top">
            <td class="p-2 font-bold">${s.count}</td>
            <td class="p-2 font-medium">${safeText(s.menu)}</td>
            <td class="p-2 text-slate-700">
              <div class="flex flex-wrap gap-1">
                ${names.map(n => `<span class="px-2 py-0.5 rounded-full bg-slate-100">${safeText(n)}</span>`).join("")}
              </div>
            </td>
          </tr>
        `;
      }).join("");

      wireRowButtons();
    }

    function wireRowButtons() {
      pendingTbody.querySelectorAll(".doneBtn").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.dataset.id;
          await updateDoc(doc(db, "sessions", currentSessionId, "entries", id), {
            called: true,
            calledAt: serverTimestamp()
          });
        });
      });

      pendingTbody.querySelectorAll(".undoBtn").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.dataset.id;
          await updateDoc(doc(db, "sessions", currentSessionId, "entries", id), {
            called: false,
            calledAt: null
          });
        });
      });
    }

    function subscribeEntries(sessionId) {
      if (unsubscribeEntries) unsubscribeEntries();

      const entriesRef = collection(db, "sessions", sessionId, "entries");
      const q = query(entriesRef, orderBy("createdAt", "asc"));

      unsubscribeEntries = onSnapshot(q, (snap) => {
        const entries = snap.docs.map((d, i) => ({ id: d.id, _idx: i, ...d.data() }));
        cachedEntries = entries;
        render(entries);
        setStatus(`연결됨 · 세션 ${sessionId.slice(0, 8)} · ${new Date().toLocaleString()}`);
      }, (err) => {
        console.error(err);
        setStatus("오류: Firestore 연결 실패. 규칙/권한/네트워크를 확인하세요.");
      });
    }

    async function createNewSessionAndSwitch() {
      const newId = crypto.randomUUID();
      await setDoc(doc(db, "sessions", newId), { createdAt: serverTimestamp() });
      await setDoc(stateRef, { currentSessionId: newId, updatedAt: serverTimestamp() }, { merge: true });
    }

    // ===== 이벤트 =====
    $("addBtn").addEventListener("click", async () => {
      const name = normalizeName($("nameInput").value);
      const menu = normalizeMenu($("menuInput").value);

      if (!name || !menu) {
        alert("이름/메뉴를 입력해 주세요.");
        return;
      }

      // ✅ 같은 (이름 + 메뉴) 중복 방지
      const dup = cachedEntries.some(e =>
        normalizeName(e.name) === name && normalizeMenu(e.menu) === menu
      );
      if (dup) {
        alert("이미 입력되었습니다.");
        return;
      }

      const entriesRef = collection(db, "sessions", currentSessionId, "entries");
      await addDoc(entriesRef, {
        name,
        menu,
        called: false,
        createdAt: serverTimestamp(),
        calledAt: null,
      });

      $("nameInput").value = "";
      $("menuInput").value = "";
      $("nameInput").focus();
    });

    $("quickClearBtn").addEventListener("click", () => {
      $("nameInput").value = "";
      $("menuInput").value = "";
      $("nameInput").focus();
    });

    $("resetBtn").addEventListener("click", async () => {
      const ok = confirm("정말 '전체 초기화(새 세션)' 할까요?\n(기존 데이터는 삭제되지 않고, 새 명단으로 전환됩니다.)");
      if (!ok) return;
      await createNewSessionAndSwitch();
    });

    // Enter 키로 입력
    $("menuInput").addEventListener("keydown", (e) => {
      if (e.key === "Enter") $("addBtn").click();
    });
    $("nameInput").addEventListener("keydown", (e) => {
      if (e.key === "Enter") $("menuInput").focus();
    });

    // ===== 시작 =====
    setStatus("로그인/연결 중...");
    await signInAnonymously(auth);
    await ensureState();

    onSnapshot(stateRef, (snap) => {
      const data = snap.data();
      if (!data?.currentSessionId) return;

      const nextSessionId = data.currentSessionId;
      if (nextSessionId !== currentSessionId) {
        currentSessionId = nextSessionId;
        sessionLabelEl.textContent = `· 현재 세션: ${currentSessionId.slice(0, 8)}`;
        subscribeEntries(currentSessionId);
      }
    });
  </script>
</body>
</html>
